Description: fix denial of service via incomplete connections
Origin: backport, http://cgit.freedesktop.org/dbus/dbus/commit/?h=dbus-1.6&id=a3477feb7aa8658602cceb8d29ae370a83002172
Origin: backport, http://cgit.freedesktop.org/dbus/dbus/commit/?h=dbus-1.6&id=89219baab0bf6ff05142518110f45c8159be8092
Bug: https://bugs.freedesktop.org/show_bug.cgi?id=80919

Index: dbus-1.4.18/bus/bus.c
===================================================================
--- dbus-1.4.18.orig/bus/bus.c	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/bus/bus.c	2014-09-17 12:00:55.602236078 -0400
@@ -39,6 +39,7 @@
 #include <dbus/dbus-hash.h>
 #include <dbus/dbus-credentials.h>
 #include <dbus/dbus-internals.h>
+#include <dbus/dbus-server-protected.h>
 
 #ifdef DBUS_CYGWIN
 #include <signal.h>
@@ -68,6 +69,7 @@
   unsigned int syslog : 1;
   unsigned int keep_umask : 1;
   unsigned int allow_anonymous : 1;
+  dbus_bool_t watches_enabled;
 };
 
 static dbus_int32_t server_data_slot = -1;
@@ -754,6 +756,8 @@
       goto failed;
     }
 
+  context->watches_enabled = TRUE;
+
   context->registry = bus_registry_new (context);
   if (context->registry == NULL)
     {
@@ -1665,3 +1669,36 @@
   _dbus_verbose ("security policy allowing message\n");
   return TRUE;
 }
+
+void
+bus_context_check_all_watches (BusContext *context)
+{
+  DBusList *link;
+  dbus_bool_t enabled = TRUE;
+
+  if (bus_connections_get_n_incomplete (context->connections) >=
+      bus_context_get_max_incomplete_connections (context))
+    {
+      enabled = FALSE;
+    }
+
+  if (context->watches_enabled == enabled)
+    return;
+
+  context->watches_enabled = enabled;
+
+  for (link = _dbus_list_get_first_link (&context->servers);
+       link != NULL;
+       link = _dbus_list_get_next_link (&context->servers, link))
+    {
+      /* A BusContext might contains several DBusServer (if there are
+       * several <listen> configuration items) and a DBusServer might
+       * contain several DBusWatch in its DBusWatchList (if getaddrinfo
+       * returns several addresses on a dual IPv4-IPv6 stack or if
+       * systemd passes several fds).
+       * We want to enable/disable them all.
+       */
+      DBusServer *server = link->data;
+      _dbus_server_toggle_all_watches (server, enabled);
+    }
+}
Index: dbus-1.4.18/bus/bus.h
===================================================================
--- dbus-1.4.18.orig/bus/bus.h	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/bus/bus.h	2014-09-17 12:00:55.602236078 -0400
@@ -133,5 +133,6 @@
                                                                   DBusConnection   *proposed_recipient,
                                                                   DBusMessage      *message,
                                                                   DBusError        *error);
+void              bus_context_check_all_watches                  (BusContext       *context);
 
 #endif /* BUS_BUS_H */
Index: dbus-1.4.18/bus/config-parser.c
===================================================================
--- dbus-1.4.18.orig/bus/config-parser.c	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/bus/config-parser.c	2014-09-17 12:00:55.602236078 -0400
@@ -427,7 +427,7 @@
        * and legitimate auth will fail.  If interactive auth (ask user for
        * password) is allowed, then potentially it has to be quite long.
        */
-      parser->limits.auth_timeout = 30000; /* 30 seconds */
+      parser->limits.auth_timeout = 5000; /* 5 seconds */
 
       /* Do not allow a fd to stay forever in dbus-daemon
        * https://bugs.freedesktop.org/show_bug.cgi?id=80559
Index: dbus-1.4.18/bus/connection.c
===================================================================
--- dbus-1.4.18.orig/bus/connection.c	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/bus/connection.c	2014-09-17 12:00:55.602236078 -0400
@@ -299,6 +299,10 @@
           _dbus_list_remove_link (&d->connections->incomplete, d->link_in_connection_list);
           d->link_in_connection_list = NULL;
           d->connections->n_incomplete -= 1;
+
+          /* If we have dropped below the max. number of incomplete
+           * connections, start accept()ing again */
+          bus_context_check_all_watches (d->connections->context);
         }
       
       _dbus_assert (d->connections->n_incomplete >= 0);
@@ -779,31 +783,17 @@
   
   dbus_connection_ref (connection);
 
-  /* Note that we might disconnect ourselves here, but it only takes
-   * effect on return to the main loop. We call this to free up
-   * expired connections if possible, and to queue the timeout for our
-   * own expiration.
-   */
   bus_connections_expire_incomplete (connections);
   
-  /* And we might also disconnect ourselves here, but again it
-   * only takes effect on return to main loop.
-   */
-  if (connections->n_incomplete >
-      bus_context_get_max_incomplete_connections (connections->context))
-    {
-      _dbus_verbose ("Number of incomplete connections exceeds max, dropping oldest one\n");
-      
-      _dbus_assert (connections->incomplete != NULL);
-      /* Disconnect the oldest unauthenticated connection.  FIXME
-       * would it be more secure to drop a *random* connection?  This
-       * algorithm seems to mean that if someone can create new
-       * connections quickly enough, they can keep anyone else from
-       * completing authentication. But random may or may not really
-       * help with that, a more elaborate solution might be required.
-       */
-      dbus_connection_close (connections->incomplete->data);
-    }
+  /* The listening socket is removed from the main loop,
+   * i.e. does not accept(), while n_incomplete is at its
+   * maximum value; so we shouldn't get here in that case */
+  _dbus_assert (connections->n_incomplete <=
+      bus_context_get_max_incomplete_connections (connections->context));
+
+  /* If we have the maximum number of incomplete connections,
+   * stop accept()ing any more, to avert a DoS. See fd.o #80919 */
+  bus_context_check_all_watches (d->connections->context);
   
   retval = TRUE;
 
@@ -1485,6 +1475,10 @@
   _dbus_assert (d->connections->n_incomplete >= 0);
   _dbus_assert (d->connections->n_completed > 0);
 
+  /* If we have dropped below the max. number of incomplete
+   * connections, start accept()ing again */
+  bus_context_check_all_watches (d->connections->context);
+
   /* See if we can remove the timeout */
   bus_connections_expire_incomplete (d->connections);
 
@@ -2387,3 +2381,16 @@
 
   return TRUE;
 }
+
+int
+bus_connections_get_n_active (BusConnections *connections)
+{
+  return connections->n_completed;
+}
+
+int
+bus_connections_get_n_incomplete (BusConnections *connections)
+{
+  return connections->n_incomplete;
+}
+
Index: dbus-1.4.18/bus/connection.h
===================================================================
--- dbus-1.4.18.orig/bus/connection.h	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/bus/connection.h	2014-09-17 12:00:55.602236078 -0400
@@ -138,4 +138,7 @@
                                                   void                         *data,
                                                   DBusFreeFunction              free_data_function);
 
+int bus_connections_get_n_active                  (BusConnections *connections);
+int bus_connections_get_n_incomplete              (BusConnections *connections);
+
 #endif /* BUS_CONNECTION_H */
Index: dbus-1.4.18/dbus/dbus-server-protected.h
===================================================================
--- dbus-1.4.18.orig/dbus/dbus-server-protected.h	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/dbus/dbus-server-protected.h	2014-09-17 12:00:55.602236078 -0400
@@ -99,9 +99,8 @@
                                          DBusWatch              *watch);
 void        _dbus_server_remove_watch   (DBusServer             *server,
                                          DBusWatch              *watch);
-void        _dbus_server_toggle_watch   (DBusServer             *server,
-                                         DBusWatch              *watch,
-                                         dbus_bool_t             enabled);
+void        _dbus_server_toggle_all_watches (DBusServer         *server,
+                                             dbus_bool_t         enabled);
 dbus_bool_t _dbus_server_add_timeout    (DBusServer             *server,
                                          DBusTimeout            *timeout);
 void        _dbus_server_remove_timeout (DBusServer             *server,
Index: dbus-1.4.18/dbus/dbus-server.c
===================================================================
--- dbus-1.4.18.orig/dbus/dbus-server.c	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/dbus/dbus-server.c	2014-09-17 12:00:55.602236078 -0400
@@ -298,26 +298,17 @@
 }
 
 /**
- * Toggles a watch and notifies app via server's
- * DBusWatchToggledFunction if available. It's an error to call this
- * function on a watch that was not previously added.
+ * Toggles all watch and notifies app via server's
+ * DBusWatchToggledFunction if available.
  *
  * @param server the server.
- * @param watch the watch to toggle.
  * @param enabled whether to enable or disable
  */
 void
-_dbus_server_toggle_watch (DBusServer  *server,
-                           DBusWatch   *watch,
-                           dbus_bool_t  enabled)
+_dbus_server_toggle_all_watches (DBusServer  *server,
+                                dbus_bool_t  enabled)
 {
-  _dbus_assert (watch != NULL);
-
-  HAVE_LOCK_CHECK (server);
-  protected_change_watch (server, watch,
-                          NULL, NULL,
-                          _dbus_watch_list_toggle_watch,
-                          enabled);
+  _dbus_watch_list_toggle_all_watches (server->watches, enabled);
 }
 
 /** Function to be called in protected_change_timeout() with refcount held */
Index: dbus-1.4.18/dbus/dbus-watch.c
===================================================================
--- dbus-1.4.18.orig/dbus/dbus-watch.c	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/dbus/dbus-watch.c	2014-09-17 12:00:55.602236078 -0400
@@ -437,6 +437,27 @@
 }
 
 /**
+ * Sets all watches to the given enabled state, invoking the
+ * application's DBusWatchToggledFunction if appropriate.
+ *
+ * @param watch_list the watch list.
+ * @param enabled #TRUE to enable
+ */
+void
+_dbus_watch_list_toggle_all_watches (DBusWatchList           *watch_list,
+                                     dbus_bool_t              enabled)
+{
+  DBusList *link;
+
+  for (link = _dbus_list_get_first_link (&watch_list->watches);
+       link != NULL;
+       link = _dbus_list_get_next_link (&watch_list->watches, link))
+    {
+      _dbus_watch_list_toggle_watch (watch_list, link->data, enabled);
+    }
+}
+
+/**
  * Sets the handler for the watch.
  *
  * @todo this function only exists because of the weird
Index: dbus-1.4.18/dbus/dbus-watch.h
===================================================================
--- dbus-1.4.18.orig/dbus/dbus-watch.h	2014-09-17 12:00:55.610236078 -0400
+++ dbus-1.4.18/dbus/dbus-watch.h	2014-09-17 12:00:55.606236078 -0400
@@ -74,6 +74,8 @@
 void           _dbus_watch_list_toggle_watch  (DBusWatchList           *watch_list,
                                                DBusWatch               *watch,
                                                dbus_bool_t              enabled);
+void           _dbus_watch_list_toggle_all_watches (DBusWatchList      *watch_list,
+                                               dbus_bool_t              enabled);
 dbus_bool_t    _dbus_watch_get_enabled        (DBusWatch              *watch);
 
 /** @} */
